#!/home/tell/venv/bin/python3
# -*- coding: utf-8 -*-

import time
import argparse
import subprocess
import os
import re
import requests
from perlish import *
import sgtmqtt

mqhost="localhost"
mymq = None
#minutes_per_update = 4
minutes_per_update = 0.5
fwid=1
baseurl = "http://titania.telltronics.org/cgi-bin/mb-cgi"

topics = [
    # mqtt topic 	            type
    [ "monbox/cpu_load",  float], 
    [ "monbox/cpu_temp",  float], 
    [ "monbox/room_temp",  float], 
    [ "monbox/room_humidity",  float], 
]

parser =  argparse.ArgumentParser(description="subscribe to several mqtt topics and log their values periodicly");
parser.add_argument("--verbose", "-v", default=False, action='store_true');
args = parser.parse_args();

topicinfo = None
messages_seen = 0
tmnow = time.localtime() 
last_send_minute = tmnow.tm_min

def get_fwid():
    fn = "/home/envmonbox/clientid"
    f = open(fn, "r");
    s = f.readline(); # .decode("utf-8")  # default?
    f.close()
    fwid = int(s)
    printf("fwid=%d\n", fwid)
    return fwid

def init_topicinfo():
    global topicinfo
    topicinfo = dict()
    for titem in list(topics):
        t = titem[0]
        ttype = titem[1]
        topicinfo[t] = dict()
        td = topicinfo[t] 
        td['last'] = None
        td['type'] = ttype
        td['lasttime'] = 0
#    printf("topicinfo=%s\n", str(topicinfo));


def on_connect(mq, userdata, flags, rc):
    print("Connected with result code "+str(rc))
    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    if(mq):
        mq.subscribe("monbox/#")


def on_message(msg):
    global topicinfo
    global messages_seen
    topic = str(msg.topic)
#    printf("msg topic=\"%s\"\n", topic)
    
    if(topic in topicinfo):
        messages_seen += 1
        topicinfo[topic]['lasttime'] = time.time()
        ttype = topicinfo[topic]['type']
        if(ttype == float):
            s = msg.payload.decode('ascii')
            topicinfo[topic]['last'] = float(s)
        elif(ttype == str):
             topicinfo[topic]['last'] = msg.payload.decode('ascii')
        elif(ttype == int):
             s = msg.payload.decode('ascii')
             topicinfo[topic]['last'] = int(s, 0);
        else:
             topicinfo[topic]['last'] = msg.payload
        printf("msg %s topcinfo=%s\n", topic, topicinfo[topic])

def print_current():
    "print current info on all known topics"
    global topicinfo
    for t, td in topicinfo.items():
        printf(" %30s %12d %10s\n", t, td['lasttime'], str(td['last']))
    printf("\n");

def fstr_if_not_old(topic, fname):
    global topicinfo
    now = time.time()
    lasttime = topicinfo[topic]['lasttime']
    if(now - lasttime < 150):
        return sprintf("&%s=%s", fname, str(topicinfo[topic]['last']))
    else:
        printf(" fstr_if %s too old now=%d lasttime=%d delta=%d\n", fname, now, lasttime, now - lasttime)
        return ""
             
def periodic():
    global last_send_minute
    tmnow = time.localtime()
    printf("periodic_callback now=%d last_send=%d\n", tmnow.tm_min, last_send_minute)
    if(
        tmnow.tm_min - last_send_minute > minutes_per_update):
        last_send_minute = tmnow.tm_min
        url = baseurl + "?id=" + str(fwid)
        url += fstr_if_not_old("monbox/cpu_load",  "cpu_load")
        url += fstr_if_not_old("monbox/cpu_temp",  "cpu_temp")
        url += fstr_if_not_old("monbox/room_temp",  "room_temp")
        url += fstr_if_not_old("monbox/room_humidity",  "room_humidity")
        printf("get %s\n", url);
        r = requests.get(url);
        printf("request status %s\n", r.status_code)

def nomq_callback():
    printf("nomq_callback:\n")
    print_current()
    pass

def main():
    global mymq
    global fwid
    fwid = get_fwid()
    init_topicinfo()
    mymq = sgtmqtt.sgtmqtt(mqhost=mqhost)
    mymq.on_message = on_message
    mymq.mq.on_connect = on_connect
    mymq.periodic_callback = periodic
#    mymq.nomqtt_callback = nomq_callback
    mymq.select_loop(5)	

main()
