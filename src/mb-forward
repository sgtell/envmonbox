#!/home/tell/venv/bin/python3
# -*- coding: utf-8 -*-

import time
import argparse
import subprocess
import os
import re
from perlish import *
import sgtmqtt

mqhost="localhost"
mymq = None
minutes_per_update = 2
fwid="1234"
baseurl = "http://titania.telltronics.org/cgi-bin/mbdata"

topics = [
    # mqtt topic 	            type
    [ "monbox/cpu_load",  float], 
    [ "monbox/cpu_temp",  float], 
    [ "monbox/room_temp",  float], 
    [ "monbox/room_humidity",  float], 
]

parser =  argparse.ArgumentParser(description="subscribe to several mqtt topics and log their values periodicly");
parser.add_argument("--verbose", "-v", default=False, action='store_true');
args = parser.parse_args();

topicinfo = None
last_send_minute = None


def init_topicinfo():
    global topicinfo
    topicinfo = dict()
    for titem in list(topics):
        t = titem[0]
        ttype = titem[1]
        topicinfo[t] = dict()
        td = topicinfo[t] 
        td['last'] = None
        td['type'] = ttype
        td['lasttime'] = 0
#    printf("topicinfo=%s\n", str(topicinfo));


def on_connect(mq, userdata, flags, rc):
    print("Connected with result code "+str(rc))
    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    if(mq):
        mq.subscribe("monbox/#")

def on_message(msg):
    global topicinfo
#    if(args.verbose):
        #printf("message %s\n", str(msg))
#        printf(" message topic=\"%s\" payload=%s\n", msg.topic, msg.payload)
        #    topic = re.split("/", msg.topic)
#    printf("topic=%s\n", str(topic))
    handled = False
#    if(topic[0] == 'aptstage'):
    if(msg.topic in topicinfo):
        handled = True
        topicinfo[msg.topic]['lasttime'] = time.time()
        ttype = topicinfo[msg.topic]['type']
        if(ttype == float):
            s = msg.payload.decode('ascii')
            topicinfo[msg.topic]['last'] = float(s)
        elif(ttype == str):
             topicinfo[msg.topic]['last'] = msg.payload.decode('ascii')
        elif(ttype == int):
             s = msg.payload.decode('ascii')
             topicinfo[msg.topic]['last'] = int(s, 0);
        else:
             topicinfo[msg.topic]['last'] = msg.payload

def print_current():
    "print current info on all known topics"
    global topicinfo
    for t, td in topicinfo.items():
        printf(" %30s %12d %10s\n", t, td['lasttime'], str(td['last']))
    printf("\n");

def fstr_if_not_old(topic, fname):
    global topicinfo
    now = time.time()
    if(now - topicinfo[topic]['lasttime'] < 150):
        return sprintf("?%s=%s", fname, str(topicinfo[topic]['last']))
    else:
        return ""
             
def periodic():
    global last_send_minute
    tmnow = time.localtime()
    if(not last_send_minute or
       tmnow.tm_min < last_send_minute or
       tmnow.tm_min - last_send_minute > minutes_per_update):
        last_send_minute = tmnow.tm_min
        url = baseurl + "?id=" + fwid
        url += fstr_if_not_old("monbox/cpu_load",  "cpu_load")
        url += fstr_if_not_old("monbox/cpu_temp",  "cpu_temp")
        url += fstr_if_not_old("monbox/room_temp",  "room_temp")
        url += fstr_if_not_old("monbox/room_humidity",  "room_humidity")
        printf("wget %s\n", url);

def nomq_callback():
    printf("nomq_callback:")
    print_current()
    pass

def main():
    global mymq
    init_topicinfo()
    mymq = sgtmqtt.sgtmqtt(mqhost=mqhost)
    mymq.on_message = on_message
    mymq.mq.on_connect = on_connect
    mymq.periodic_callback = periodic
    mymq.nomqtt_callback = nomq_callback
    mymq.select_loop(5)	

main()
